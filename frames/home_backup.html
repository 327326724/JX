<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<style>
		html {
			overflow:hidden
		}
		body {
			font-family: 'Segoe UI Light','Segoe UI','Microsoft Jhenghei','微软雅黑',sans-serif;
			position: absolute; 
			margin:0; 
			padding:0;
			width:100%; 
			height:100%;
		}
		canvas {
			display:block
		}
		p {
			text-align: center; 
			font-size:12px;
			color:#454545;
		}
	</style>
</head>

<body>
<script src="../js/JCanvas.0.1.js"></script>
<canvas id="canvas" width="600" height="400"></canvas>
<img id="qq" style="display:none" src="../images/qq40.png" />
<img id="jx" style="display:none" src="../images/jx.png" />
<script>
var JxHome = function () {
	// private methods
	function range(a, b) {
        return Math.floor(Math.random()*(b-a) + a);
    }


	var JxHomeClass = function () {
        var canvas = document.getElementById('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        var stage = new CVS.$stage(canvas);
		
		this.canvas = canvas;
		this.stage = stage;
		this.ctx = stage.ctx;
		this.place = 0;
		
		this.qqParticles = [];
		this.jxParticles = [];
		
		var focalLength = 250,
			ballN = 100,
			balls = [],
			lines = [],
			vpx = 0,
			vpy = 0,
			angleY = 0.001,
			angleX = 0.001,
			_this = this;
            Z = 100;
			

			vpx = canvas.width / 2;
			vpy = canvas.height / 2;
			
		//fillText
		
		this.qqParticles = this.getParticles('qq');
		//this.jxParticles = this.getParticles('jx');
		
		
		for (var i=0; i<ballN; i++) {
            
			var ball = CVS.createPoint3D(stage.ctx, function () {
                var color = 'rgb('+range(0, 256)+', '+range(0, 256)+', '+range(0, 256)+')';
				this.xpos = range(-10*vpx, 10*vpx);
				this.ypos = range(-10*vpy, 10*vpy);
				this.zpos = range(-10*vpy, 10*vpy);
				this.width = range(8, 15);
				this.draw = function () {
					this.ctx.beginPath();
					this.ctx.arc(0, 0, this.width/2, 0, Math.PI*2, true);
					this.ctx.closePath();
                    this.ctx.fillStyle = color;
					this.ctx.fill();
				}
			});
			ball.setVanishPoint(vpx, vpy);
			ball.setCenterPoint(0, 0, 250);
			stage.addChild(ball);
			balls.push(ball);
		}
		
        
        var step = -0.05;
		var startT = (+new Date);
		var zstep = -2;
		var zflag = 1;
		stage.onRefresh = function () { 
			var nt = (+new Date);
			if (zstep > 2 || zstep < -2) {
				zflag *= -1;
			}
			zstep += zflag*0.01;
			
			for (var j = 0; j < balls.length; j ++) {
				var ball = balls[j];
				ball.zpos += zstep;
				ball.rotateX(angleX);
			   ball.rotateY(angleY);
			   var scale = ball.getScale(),
			   pos = ball.getScreenXY();
			   ball.x = pos.x;
			   ball.y = pos.y;
			}
			
			for (var i=0,ball; ball = _this.qqParticles[i]; i++) {
			  _this.checkPos(nt-startT, ball, (i == _this.qqParticles.length-1));
			  
			  // tween
			  // 只要第一次到达终点就不要再计算，否则会一直达不到终点，因为本身ball也在旋转
			  if (!ball.end) {
				var _x = ball.xpos, _y = ball.ypos, _z = ball.zpos;
				var _t = (+new Date) - ball.startAnimTime;
					ball.xpos = ball.f_xpos + (ball.t_xpos - ball.f_xpos)*Math.sin(Math.PI*_t/(2*1000));
					ball.ypos = ball.f_ypos + (ball.t_ypos - ball.f_ypos)*Math.sin(Math.PI*_t/(2*1000));
					ball.zpos = ball.f_zpos + (ball.t_zpos - ball.f_zpos)*Math.sin(Math.PI*_t/(2*1000));

				 if (_t >= 1000) {
						ball.end = true;
						//stage.removeChild(ball);
					}
			  }
			  
			  
			  ball.zpos += zstep;
			   ball.rotateX(angleX);
			   ball.rotateY(angleY);
			   var scale = ball.getScale(),
			   pos = ball.getScreenXY();
			   ball.x = pos.x;
			   ball.y = pos.y;
            }
			
			var newArr = _this.qqParticles.concat(balls);
			newArr.sort(function (a, b) { return b.depth - a.depth });
            
		}
		// mousemove
		stage.addEventListener('mousemove', function (x, y) {
			angleY = (x - vpx) * .00001;
            angleX = (y - vpy) * .00001;
		})

		stage.start();
	};
	JxHomeClass.prototype = {
		fillText: function (s) {
			/*this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.font = '160px sans-serif';
            this.ctx.fillText('岑安', this.canvas.width/2, this.canvas.height/2);*/
			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
			this.ctx.drawImage(document.getElementById(s), 0, 0, 40, 40, this.canvas.width/2-10, this.canvas.height/2-10, 20, 20);
		},
		checkPos: function () {
			var i = 1,
				posQue = ['$random', 'logoPos'];
			return function (t, ball, once) {
				if (Math.floor(t/4000) == i) { 
					var n = i%posQue.length;
					if (posQue[n] == '$random') {
						ball.f_xpos = ball.xpos;
						ball.f_ypos = ball.ypos;
						ball.f_zpos = ball.zpos;
						ball.t_xpos = range(-this.canvas.width*15, this.canvas.width*15);
						ball.t_ypos = range(-this.canvas.height*15, this.canvas.height*15);
						ball.t_zpos = range(-this.canvas.width*5, this.canvas.width*5);
						ball.width = range(3, 15);
						ball.end = false;
						ball.startAnimTime = (+new Date);
					} else {
						ball.f_xpos = ball.xpos;
						ball.f_ypos = ball.ypos;
						ball.f_zpos = ball.zpos;
						ball.t_xpos = ball[posQue[n]].x;
						ball.t_ypos = ball[posQue[n]].y;
						ball.t_zpos = ball[posQue[n]].z;
						ball.width = ball[posQue[n]].width;
						ball.end = false;
						ball.startAnimTime = (+new Date);
					}

					if (once) {i = Math.floor(t/4000) + 1;}
					
				}
			}
		}(),
		pushParticlesByImageData: function () {
			var imageData = this.ctx.getImageData(this.canvas.width/2-10, this.canvas.height/2-10, 20, 20);
			var ret = [];
            for (var x = 0; x < imageData.width; x ++) {
                for (var y = 0; y < imageData.height; y ++) {
                    //var i = 4*(x * imageData.height + y);
                    var i = 4*(y * imageData.width + x);
                    if (imageData.data[i + 3] > 128) { // 半透以上就算
						var r = imageData.data[i],
							g = imageData.data[i + 1],
							b = imageData.data[i + 2];
                        ret.push(new Particle(this.stage, this.canvas, x, y, r, g, b));
                    }
                }
            }
			return ret;
		},
		getParticles: function (s) {
			this.fillText(s);
			return this.pushParticlesByImageData();
		}
	};
	
	// 3D Particle
	var Particle = function (stage, canvas, x, y, r, g, b) {
		this.canvas = canvas;
		
		var vpx = canvas.width/2,
			vpy = canvas.height/2;
		
		var ball =  CVS.createPoint3D(stage.ctx, function () {
			var color = 'rgb('+range(200,255)+', '+range(200,255)+', '+range(200,255)+')';
				this.xpos = range(-10*vpx, 10*vpx);
				this.ypos = range(-10*vpy, 10*vpy);
				this.zpos = range(-10*vpx, 10*vpx);
				this.width = range(3, 15);
				this.draw = function () {
					this.ctx.beginPath();
					this.ctx.arc(0, 0, this.width/2, 0, Math.PI*2, true);
					this.ctx.closePath();
                    this.ctx.fillStyle = color;
					this.ctx.fill();
				}
		});

		ball.logoPos = {
			x: (x-10)*20,
			y: (y-10)*20,
			z: 0,
			width: 10,
			r: r,
			g: g,
			b: b
		};
		ball.f_xpos = ball.xpos;
		ball.f_ypos = ball.ypos;
		ball.f_zpos = ball.zpos;
		ball.t_xpos = ball.xpos;
		ball.t_ypos = ball.ypos;
		ball.t_zpos = ball.zpos;
		ball.startAnimTime = (+new Date);
		ball.end = true;
		
		ball.setVanishPoint(canvas.width/2, canvas.height/2);
		ball.setCenterPoint(0, 0, 250);
		
		ball.moveX = 1 - Math.random()*2;
		stage.addChild(ball);
		
		return ball;
	}
	
	return JxHomeClass;
}();
    
onload = function () {
	new JxHome();
};
</script>

</body>
</html>

